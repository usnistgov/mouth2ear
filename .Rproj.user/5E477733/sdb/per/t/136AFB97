{
    "collab_server" : "",
    "contents" : "# This software was developed by employees of the National Institute of\n# Standards and Technology (NIST), an agency of the Federal Government.\n# Pursuant to title 17 United States Code Section 105, works of NIST\n# employees are not subject to copyright protection in the United States and\n# are considered to be in the public domain. Permission to freely use, copy,\n# modify, and distribute this software and its documentation without fee is\n# hereby granted, provided that this notice and disclaimer of warranty\n# appears in all copies.\n# \n# THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER\n# EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY\n# WARRANTY THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED\n# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND\n# FREEDOM FROM INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL\n# CONFORM TO THE SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR\n# FREE. IN NO EVENT SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT\n# LIMITED TO, DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING\n# OUT OF, RESULTING FROM, OR IN ANY WAY CONNECTED WITH THIS SOFTWARE,\n# WHETHER OR NOT BASED UPON WARRANTY, CONTRACT, TORT, OR OTHERWISE, WHETHER\n# OR NOT INJURY WAS SUSTAINED BY PERSONS OR PROPERTY OR OTHERWISE, AND\n# WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT OF THE RESULTS OF, OR\n# USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.\n#\n# --------------------Package Dependencies----------------------------------\n# The following functions rely on the following packages:\n# ggplot2, grid, DEoptimR, MASS, metRology, numDeriv, robustbase\n\n\nprocess.sessions <- function(all.setups,show.lags=F){\n  #' process.sessions perform uncertainty analysis and report results for list of M2E latency tests\n  #'\n  #'   process.sessions(all.setups) performs uncertainty analysis on the input test data in using the methods from the Joint Committee on Guides in Metrology (JCGM) \\emph{Guide to the Expression of Uncertainty of Measurement (GUM)}. Relies on the \n  #'   functions GUM and GUM.validate from the metRology package.\n  #'\n  #'   process.sessions(all.setups, show.lags = T) prints the maximum lag for which significant autocorrelation is present for each session of each test.\n  #'   \n  #' @param   \\code{show.lags}     \\emph{logical.}              Informs whether or not to print the maximum lag for which significant autocorrelation is present for each session of each test\n  #' @param   \\code{all.setups}    \\emph{list.}                  List containing information for all tests. Further detailed below.\n  #'\n  #'   \\code{name}          \\emph{character.}             Name of test setup (i.e. Single Location Cabled Tests)\n  #'\n  #'   \\code{path}          \\emph{character.}             Path where csv files containing delay values for all tests of test setup contained. Expects each test in individual folder containing a csv file for each session.\n  #'\n  #'   \\code{tests}         \\emph{character vector.}      Vector of names of the specfic tests performed in the test setup (i.e. c(\"Device X Direct Mode\", \"Device X Trunked Mode\", \"Device Y Direct Mode\")). Must match the folder names that contain the session csv files for that test.\n  #'\n  #'   \\code{thinning}      \\emph{numeric vector.}        Vector of degree to which the sessions of each test must be thinned to remove significant autocorrelation. For example given Device X Direct Mode must be thinned \n  #'                                       by using every third data point to eliminate significant autocorrelation, Device X Trunked must be thinned by using every fifth data point, and Device Y Direct \n  #'                                       Mode must be thinned by using every second data point then thinning would be c(3,5,2).\n  #'                                       \n  #' @return  A list containing the following components: \n  #' @return   \\code{thinned.data}  \\emph{list.}                  List with thinned data vectors for each session of each test of each test setup    \n  #'\n  #' @return   \\code{gum.data}      \\emph{list.}                  List with GUM output for each session of each test of each test setup\n  #'\n  #' @return   \\code{df}            \\emph{data.frame.}           Dataframe with GUM() output for all tests\n  #'\n  #' @return   \\code{autocorr.data} \\emph{list.}                  List with autocorr.unc() output for each session of each test of each setup\n  #'\n  #' @examples Calculation of M2E latency and uncertainty for data collected for NISTIR XXXX.\n  #' \n  #' # Full system path where 1loc data stored\n  #' oneLoc.path <- system.file(\"extdata\",\"Delay_Values\", \"1loc\", package=\"mouth2ear\")\n  #' \n  #' # Full system path where 2loc data stored\n  #' twoLoc.path <- system.file(\"extdata\",\"Delay_Values\", \"2loc\", package=\"mouth2ear\")\n  #' \n  #' # Initialize lists for all test setups used\n  #' # One location lab test setup information\n  #' oneLoc <- list(\n  #' name = \"One Location Lab\",\n  #' path = oneLoc.path,\n  #' tests = c(\n  #'   \"1loc-device-characterization\",\n  #'   \"1loc-UHF-Direct-wired-p25-lab-Vol-11\",\n  #'   \"1loc-UHF-Trunked-wired-p25-lab-Vol-11\",\n  #'   \"1loc-VHF-Direct-wired-p25-lab-Vol-11\",\n  #'   \"1loc-VHF-Trunked-wired-p25-lab-Vol-11\"\n  #' ),\n  #' thinning = c(3, # characterization\n  #'              4, # uhf direct\n  #'              4, # uhf trunked\n  #'              7, # vhf direct\n  #'              3 # vhf trunked\n  #' )\n  #' )\n  #' \n  #' # Two location lab test setup information\n  #' twoLoc.lab <- list(\n  #' name = \"Two Location Lab\",\n  #' path = twoLoc.path,\n  #' tests = c(\n  #'   \"p25-lab-characterization-2loc\", # characterization lab\n  #'   \"UHF-Direct-p25-lab-wired-Vol-11\", # uhf direct lab\n  #'   \"UHF-Trunked-p25-lab-wired-Vol-11\", # uhf trunked lab\n  #'   \"VHF-Direct-p25-lab-wired-Vol-11\", # vhf direct lab\n  #'   \"VHF-Trunked-p25-lab-wired-Vol-11\" # vhf trunked lab\n  #' ),\n  #' thinning = c(4, # characterization\n  #'              3, # lab uhf direct\n  #'              5, # lab uhf trunked\n  #'              5, # lab vhf direct\n  #'              5 # lab vhf trunked\n  #' )\n  #' \n  #' )\n  #' # Two location field test setup information\n  #' twoLoc.field <- list(\n  #' name = \"Two Location Lab\",\n  #' path = twoLoc.path,\n  #' tests = c(\n  #'     \"p25-lab-characterization-2loc\", # characterization lab\n  #'     \"UHF-Direct-US36-G\", # uhf direct field\n  #'     \"UHF-Trunked-US36-G\", #uhf trunked field\n  #'     \"VHF-Direct-US36-G\", # vhf direct field\n  #'     \"VHF-Trunked-US36-G\" # vhf trunked field\n  #' ),\n  #' thinning = c(4, # characterization\n  #'                5, # field uhf direct\n  #'                4, # field uhf trunked\n  #'                4, # field vhf direct\n  #'           1 # field vhf trunked\n  #'   )\n  #'   \n  #' )\n  #' \n  #' # Calculate all test values and uncertainties\n  #' m2e <- process.sessions(all.setups=list(oneLoc,twoLoc.lab,twoLoc.field))\n  #' \n  #' @references Joint Committee on Guides in Metrology (JCGM), \\emph{Evaluation of Measurement Data Guide to the Expression of Uncertainty in Measurement}, http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf, 2008.\n  #'\n  #' @export\n  \n  # Initialize empty list to store delay values in\n  setup.data <- list()\n  # Initialize empty list to store GUM output in\n  test.GUM <- list()\n  \n  # Intialize list to save test autocorrelation information\n  test.autocorr <- list()\n  \n  # Measurement resolution\n  meas.res <- 0.125e-3\n  \n  \n  for (setup in all.setups) {\n    print(paste(\"-----------------\", setup$name, \"-----------------\"))\n    # Initialize list to store test data (stores each session individually)\n    test.data <- list()\n    # List to store autocorrelation plot objects in\n    plot.list <- list()\n    \n    \n    # index for referencing thinning information\n    ix = 1\n    for (test in setup$tests) {\n      # Display thinning factor for each test\n      print(paste(test, \"Thin:\", setup$thinning[ix]))\n      # Path to session files\n      dat.Path <- paste(setup$path, \"/\", test, sep = \"\")\n      # Find session files in path\n      session.files <- list.files(dat.Path)\n      # Initialize list to store individual session data\n      session.data <- list()\n      \n      # Iniitialize list to store session uncertainty information\n      session.unc <- list()\n      \n      # Initialize list to store autocorrelation information\n      session.autocorr<- list()\n      \n      for (session in session.files) {\n        # Load in raw data from csv file\n        session.data.raw <-\n          read.csv(paste(dat.Path, \"/\", session, sep = \"\"), header = F)\n        \n        # Find trial means\n        trial.m <- rowMeans(session.data.raw)\n        # Thin data by thinning factor\n        trial.m <-\n          trial.m[seq(from = 1,\n                      to = length(trial.m),\n                      by = setup$thinning[ix])]\n        \n        \n        # Store row means in session.data\n        session.data[[gsub(\".csv\", \"\", session)]] <- trial.m\n        \n        # Find autocorrelation info\n        autocorr <- autocorr.unc(trial.m)\n        \n        # Store session uncertainties\n        session.unc[[gsub(\".csv\",\"\", session)]] <- autocorr$u\n        \n        # Store session autocorrelation\n        session.autocorr[[gsub(\".csv\",\"\",session)]] <- autocorr\n        \n        # # Print lags\n        if(show.lags){\n          print(paste(\"---- Lag:\", autocorr$lag))\n        }\n        \n        if(autocorr$lag>0){\n          warning(\"Session autocorrelated, GUM assumptions invalidated...\")\n        }\n        \n        # Initialize plot name\n        plot.name <- paste(test, session)\n        # Clean plot names\n        plot.name <- gsub(\"session_\", \"\", gsub(\"-\",\" \", gsub(\"p25-lab-\", \"\", gsub(\".csv\", \"\", plot.name))))\n        \n        \n      }\n      # Store test data\n      test.data[[test]] <- session.data\n      \n      # Store autocorrelation data\n      test.autocorr[[test]] <- session.autocorr\n      # Increment test index\n      ix = ix + 1\n      \n      # define number of sessions\n      n <- length(session.unc)\n      \n      if(grepl(\"characterization\",test)){\n        # GUM for device characterization tests\n        # Define measurement equation as measurement resolution (d) plus the mean delay over all sessions\n        meas.fnc <- paste(\"d+1/\", n, \"*(\", paste(\"s\",1:n, sep=\"\", collapse=\"+\"), \")\", sep=\"\")\n        \n        # Use GUM to find uncertainty and additional uncertainty properties\n        test.uncertainty <- GUM(var.name=c(paste(\"s\",1:length(session.unc),sep=\"\"),\"d\"),\n                                x.i=c(unlist(lapply(session.data,mean)),0),\n                                u.i=c(unlist(session.unc),meas.res/sqrt(12)),\n                                nu.i=c(rep(length(trial.m)-1,length(session.unc)),Inf),\n                                measurement.fnc=meas.fnc)\n        \n        # Run validation check (via Monte Carlo simulations) to see how well 95% Confidence Level achieved by GUM approximation\n        test.uncertainty$valid <- GUM.validate(var.name=c(paste(\"s\",1:length(session.unc),sep=\"\"),\"d\"),\n                                               x.i=c(unlist(lapply(session.data,mean)),0),\n                                               u.i=c(unlist(session.unc),meas.res/sqrt(12)),\n                                               nu.i=c(rep(length(trial.m)-1,length(session.unc)),9999),\n                                               type=c(rep(\"A\",length(session.unc)),\"A\"),\n                                               distribution= c(rep(\"Normal\",length(session.unc)),\"Uniform\"),\n                                               measurement.fnc=meas.fnc)\n        # Initialize temporary vector\n        tmp.vec<-as.data.frame(test.uncertainty$contributions)\n        # Add new factor to uncertainty contributions\n        tmp.vec[[\"c\"]]<-NA\n        # Update uncertainty contributions\n        test.uncertainty$contributions<-as.matrix(tmp.vec)\n        \n        # Initialize temporary vector\n        tmp.vec<-as.data.frame(test.uncertainty$sensitivities)\n        # Add new factor to uncertainty sensitivities\n        tmp.vec[[\"c\"]]<-NA\n        \n        # Update uncertainty sensitivities\n        test.uncertainty$sensitivities<-as.matrix(tmp.vec)\n        \n        \n      }\n      else{\n        # GUM for Device test\n        # Define system latency\n        # Find characterizaion test name\n        test.character <- setup$tests[grepl(\"characterization\",setup$tests)]\n        \n        # Find GUM ouptut for characterization test\n        GUM.character <- test.GUM[[test.character]]\n        \n        # Define measurement equation as measurement resolution (d) plus the mean delay over all sessions minus system latency (c)\n        meas.fnc <- paste(\"d+1/\", n, \"*(\", paste(\"s\",1:n, sep=\"\", collapse=\"+\"), \") - c\", sep=\"\")\n        \n        # Use GUM to find uncertainty and additional uncertainty properties\n        test.uncertainty <- GUM(var.name=c(paste(\"s\",1:length(session.unc),sep=\"\"),\"d\",\"c\"),\n                                x.i=c(unlist(lapply(session.data,mean)),0,GUM.character$y),\n                                u.i=c(unlist(session.unc),meas.res/sqrt(12),GUM.character$u),\n                                nu.i=c(rep(length(trial.m)-1,length(session.unc)),Inf, GUM.character$nu.eff),\n                                measurement.fnc=meas.fnc)\n        \n        # Run validation check (via Monte Carlo simulations) to see how well 95% Confidence Level achieved by GUM approximation\n        test.uncertainty$valid <- GUM.validate(var.name=c(paste(\"s\",1:length(session.unc),sep=\"\"),\"d\", \"c\"),\n                                               x.i=c(unlist(lapply(session.data,mean)),0, GUM.character$y),\n                                               u.i=c(unlist(session.unc),meas.res/sqrt(12),GUM.character$u),\n                                               nu.i=c(rep(length(trial.m)-1,length(session.unc)),9999,GUM.character$nu.eff),\n                                               type=c(rep(\"A\",length(session.unc)),\"A\",\"A\"),\n                                               distribution= c(rep(\"Normal\",length(session.unc)),\"Uniform\",\"Normal\"),\n                                               measurement.fnc=meas.fnc)\n        \n      }\n      # Remove msgs from list\n      test.uncertainty$msgs<-NULL\n      # Store test uncertainty\n      test.GUM[[test]] <- test.uncertainty\n      \n    }\n    # Store setup data\n    setup.data[[gsub(\" \", \".\", setup$name)]] <- test.data\n    \n  }\n  \n  \n  # Store GUM output as dataframe\n  df <- data.frame(matrix(unlist(test.GUM),ncol=length(unlist(test.GUM$`1loc-device-characterization`)),byrow=T),stringsAsFactors = T)\n  colnames(df) <- names(unlist(test.GUM$`1loc-device-characterization`))\n  rownames(df) <- names(test.GUM)\n  \n  # return data\n  return(list(thinned.data=setup.data,\n              gum.data = test.GUM,\n              df = df,\n              autocorr.data = test.autocorr))\n  \n}\n\n#========================================================================================================================================================================\n\nacf.adj <- function(autocorr,plot.title = \"\",lag.max=NULL,show.plot=TRUE){\n  #' Plots estimates of autocorrelation generated from autocorr.unc()\n  #'\n  #' Similar to R default acf() function, can also plot arbitrary bound lines. Useful when plotting the cut off lag proposed by Zhang in Calculation of the uncertainty of the mean of autocorrelated measurements (2006).\n  #'\n  #' @param    \\code{autocorr}  \\emph{list.}      Output of autocorr.unc(y) (see below), where y is a vector of the relevant data\n  #'\n  #' @param   \\code{plot.title}    \\emph{character.}             Title of the desired ACF plot\n  #'\n  #' @param \\code{lag.max}       \\emph{Numeric.}               Maximum lag to be shown in ACF plot\n  #'\n  #' @param   \\code{show.plot}     \\emph{logical.}               Show plot in Rstudio window or not\n  #'\n  #' @return   \\code{fplot}         \\emph{ggplot}                Plot object of ACF plot\n  #' \n  #' @references Zhang NF (2006) Calculation of the uncertainty of the mean of autocorrelated measurements. \\emph{Metrologia} 43(4):S276. URL http://stacks.iop.org/0026-1394/43/i=4/a=S15.\n  #' \n  #' @examples # Generate a set of 1000 numbers from the standard normal distribution\n  #' y <- rnorm(1000)\n  #' \n  #' # Calculate the autocorrelation and adjusted uncertainty for y\n  #' autocorr <- autocorr.unc(y)\n  #' \n  #' # Plot acf plot with adjusted bounds defined by autocorr.unc\n  #' fig <- acf.adj(autocorr)\n  #' \n  #' @export\n  \n  \n  if(is.null(lag.max)){\n    # If lag.max not set, initiate it to a quarter of the size of the data\n    lag.max <- length(autocorr$rho)/4\n  }\n  # Set xvalues\n  xvals <- 1:lag.max\n  # Define sample\n  sample <- autocorr$rho[xvals]\n  # Define bound\n  bound <- 1.96*autocorr$sigma[xvals]\n  # Define normal bound\n  norm.bnd <- 1.96/sqrt(length(autocorr$rho))\n  \n  # Define lag\n  lag <- autocorr$lag\n  \n  # Initiate plot\n  g <- ggplot() \n  # Plot\n  fplot<- g + \n    # Plot autocorrelation bars\n    geom_col(aes(x=xvals, y= sample)) +\n    # Plot bound lines\n    # geom_line(aes(x=xvals,y=bound,color=\"red\"),linetype=\"dotted\",size = 1.5) + geom_line(aes(x=xvals,y=-bound,color=\"red\"),linetype=\"dotted\",size=1.5) + \n    geom_line(aes(x=xvals,y=bound,color=\"red\"),size = 1.5) + geom_line(aes(x=xvals,y=-bound,color=\"red\"),size=1.5) + \n    # Plot normal bound lines\n    geom_hline(yintercept=norm.bnd) + geom_hline(yintercept=-norm.bnd) +\n    # Plot lag line\n    geom_vline(xintercept=lag,color=\"blue\") + \n    # Remove legend\n    theme(legend.position = \"none\") +\n    # plot title\n    ggtitle(plot.title)+\n    xlab(\"\") + ylab(\"\")\n  if(show.plot){\n    print(fplot)\n  }\n  return(fplot)\n  \n}\n#========================================================================================================================================================================\nautocorr.unc <- function(y) {\n  #' Determine if data autocorrelated and calculate corrected uncertainty autocorrelated data\n  #'\n  #'\n  #' @param   \\code{y}             \\emph{numeric vector}        Vector of data on which to calculate sample autocorrelation and uncertainty\n  #' \n  #' @return  A list with the following elements:\n  #' \n  #' \\code{u}             \\emph{numeric.}               Uncertainty corrected for autocorrelation if significant autocorrelation detected\n  #'\n  #' \\code{lag}           \\emph{numeric.}               Maximum lag for which significant autocorrelation present (i.e. element k and element k+lag have significant autocorrelation)\n  #'\n  #' \\code{rho}           \\emph{numeric vector.}        Sample autocorrelation\n  #'\n  #' \\code{sigma}         \\emph{numeric Vector.}        Sample autocorrelation variance estimator\n  #'\n  #' \\code{r}             \\emph{numeric.}               Ratio between uncertainty of corrected uncertainty versus uncorrected uncertainty\n  #'\n  #'\n  #'@references Zhang NF (2006) Calculation of the uncertainty of the mean of autocorrelated measurements. \\emph{Metrologia} 43(4):S276. URL http://stacks.iop.org/0026-1394/43/i=4/a=S15.\n  #' @export\n  \n  \n  \n  # remove na values from y\n  y <- y[!is.na(y)]\n  \n  # Calculate the standard deviation of y, na values removed\n  s.y <- sd(y, na.rm = T)\n  \n  # sample mean of y\n  m.y <- mean(y, na.rm = T)\n  \n  # length of y\n  n <- length(y)\n  \n  # initialize sample autocorrelation vector of na\n  rho <- c(rep(NA, n))\n  \n  # sample autocorrelation variance estimator\n  sigma <- c(rep(NA, n))\n  \n  for (i in 1:n) {\n    sv <- 0\n    \n    if (i<n) {\n      for (k in (1:(n - i))) {\n        # NOTE: bug here when i==n, then k is in c(1,0)...need some way to stop this...\n        sv <- sv + (y[k] - m.y) * (y[k + i] - m.y)\n      }\n    }\n    # sample autocorrelation from equation 10\n    rho[i] <- sv / ((n - 1) * s.y ^ 2)\n    \n    \n    # Sample autocorrelation variance estimator (equation 17)\n    if (i == 1) {\n      sigma[i] <- 1 / sqrt(n)\n    }\n    else{\n      sigma[i] <- sqrt((1 + 2 * sum(rho[1:(i - 1)] ^ 2)) / n)\n    }\n    \n  }\n  \n  # Cut off lag, equation 16\n  lim <- which(abs(rho) > 1.96 * sigma)\n  \n  # If no autocorrelation, return normal uncertainty\n  if (length(lim) > 0) {\n    n.c <- lim[length(lim)]\n  }\n  else{\n    n.c <- 0\n    u <- s.y / sqrt(n)\n    lag <- 0\n    r <- 1\n    return(list(\n      u = u,\n      lag = lag,\n      rho = rho,\n      sigma = sigma,\n      r = r\n    ))\n  }\n  # Upper bound, equation 17\n  lag <- min(c(n.c, floor(n / 4)))\n  dv = seq(n - 1, n - lag, -1)\n  # Ratio from equation 20\n  r = 1 + 2 * (dv %*% rho[1:lag]) / n\n  \n  # uncertainty squared estimator equation 19\n  u.2 <- r * (s.y ^ 2) / n\n  \n  # standard deviation estimator\n  if(u.2>0){\n    u <- sqrt(u.2)\n  }\n  else{\n    u<- NaN\n  }\n  return(list(\n    u = u,\n    lag = lag,\n    rho = rho,\n    sigma = sigma,\n    r = r\n  ))\n}\n",
    "created" : 1517346638411.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "126982466",
    "id" : "136AFB97",
    "lastKnownWriteTime" : 1517517663,
    "last_content_update" : 1517517664872,
    "path" : "H:/MCV/M2E-Latency/device-tst/mouth2ear/R/session-processing.R",
    "project_path" : "mouth2ear/R/session-processing.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}